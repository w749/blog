<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="Spark进阶-SparkContext之SparnEnv"><meta name="keywords" content="Spark"><meta name="author" content="WangXun"><meta name="copyright" content="WangXun"><title>Spark进阶-SparkContext之SparnEnv | Wake</title><link rel="shortcut icon" href="/img/favicon-blank.svg"><link rel="stylesheet" href="/css/index.css?version=1.9.1"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.9.1"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/instantsearch.js@2.1.1/dist/instantsearch.min.css"><script src="https://cdn.jsdelivr.net/npm/instantsearch.js@2.1.1/dist/instantsearch.min.js" defer></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.css"><script src="https://cdn.jsdelivr.net/npm/gitalk@latest/dist/gitalk.min.js"></script><script src="https://cdn.jsdelivr.net/npm/blueimp-md5@2.10.0/js/md5.min.js"></script><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script src="https://v1.hitokoto.cn/?encode=js&amp;charset=utf-8&amp;select=.footer_custom_text" defer></script><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: {"appId":"HSM2EINL2X","apiKey":"6f1478b12150efd917d5ecfcddfb8b8b","indexName":"wangxun","hits":{"per_page":10},"languages":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}.","hits_stats":"${hits} results found in ${time} ms"}},
  localSearch: undefined,
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  hexoVersion: '6.0.0'
} </script><meta name="generator" content="Hexo 6.0.0"></head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="true"><div class="toggle-sidebar-info text-center"><span data-toggle="Toggle article">Toggle site</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">Catalog</div><div class="sidebar-toc__progress"><span class="progress-notice">You've read</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#SerializerManager"><span class="toc-number">1.</span> <span class="toc-text">SerializerManager</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#BroadcastManager"><span class="toc-number">2.</span> <span class="toc-text">BroadcastManager</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#MapOutputTracker"><span class="toc-number">3.</span> <span class="toc-text">MapOutputTracker</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#MapOutputTrackerMaster"><span class="toc-number">3.1.</span> <span class="toc-text">MapOutputTrackerMaster</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Shuffle%E6%B3%A8%E5%86%8C"><span class="toc-number">3.2.</span> <span class="toc-text">Shuffle注册</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9E%84%E5%BB%BA%E5%AD%98%E5%82%A8%E4%BD%93%E7%B3%BB"><span class="toc-number">4.</span> <span class="toc-text">构建存储体系</span></a></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="/img/avatar.jpg"></div><div class="author-info__name text-center">WangXun</div><div class="author-info__description text-center"></div><div class="follow-button"><a target="_blank" rel="noopener" href="https://github.com/w749">Follow Me</a></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">Articles</span><span class="pull-right">71</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">Tags</span><span class="pull-right">20</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">Categories</span><span class="pull-right">6</span></a></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(/img/top-img.jpg)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">Wake</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">Home</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/categories">Categories</a></span><span class="pull-right"><a class="site-page social-icon search"><i class="fa fa-search"></i><span> Search</span></a></span></div><div id="post-info"><div id="post-title">Spark进阶-SparkContext之SparnEnv</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2022-08-11</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/Software/">Software</a><div class="post-meta-wordcount"><span>Word count: </span><span class="word-count">3.6k</span><span class="post-meta__separator">|</span><span>Reading time: 15 min</span></div></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><p>主要介绍了SparkEnv的创建和主要组件的重要功能</p>
<span id="more"></span>

<p>Spark对任务的计算都依托于Executor的能力，所有的Executor都有自己的Spark执行环境SparkEnv。有了SparkEnv，就可以将数据存储在存储体系中；就能利用计算引擎对计算任务进行处理，就可以在节点间进行通信等。SparkEnv还提供了多种多样的内部组件，实现不同的功能</p>
<p>创建SparkEnv的主要代码是调用SparkEnv的create方法</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">def</span> <span class="title">create</span></span>(</span><br><span class="line">    conf: <span class="type">SparkConf</span>,</span><br><span class="line">    executorId: <span class="type">String</span>,</span><br><span class="line">    bindAddress: <span class="type">String</span>,</span><br><span class="line">    advertiseAddress: <span class="type">String</span>,</span><br><span class="line">    port: <span class="type">Int</span>,</span><br><span class="line">    isLocal: <span class="type">Boolean</span>,</span><br><span class="line">    numUsableCores: <span class="type">Int</span>,</span><br><span class="line">    ioEncryptionKey: <span class="type">Option</span>[<span class="type">Array</span>[<span class="type">Byte</span>]],</span><br><span class="line">    listenerBus: <span class="type">LiveListenerBus</span> = <span class="literal">null</span>,</span><br><span class="line">    mockOutputCommitCoordinator: <span class="type">Option</span>[<span class="type">OutputCommitCoordinator</span>] = <span class="type">None</span>): <span class="type">SparkEnv</span> = &#123;</span><br><span class="line">  <span class="comment">// 主要对账号、权限及身份认证进行设置和管理</span></span><br><span class="line">  <span class="keyword">val</span> securityManager = <span class="keyword">new</span> <span class="type">SecurityManager</span>(conf, ioEncryptionKey)</span><br><span class="line">  <span class="comment">// NettyRpcEnv RPC环境</span></span><br><span class="line">  <span class="keyword">val</span> rpcEnv = <span class="type">RpcEnv</span>.create(systemName, bindAddress, advertiseAddress, port, conf,</span><br><span class="line">    securityManager, clientMode = !isDriver)</span><br><span class="line">  <span class="keyword">val</span> serializer = instantiateClassFromConf[<span class="type">Serializer</span>](</span><br><span class="line">    <span class="string">&quot;spark.serializer&quot;</span>, <span class="string">&quot;org.apache.spark.serializer.JavaSerializer&quot;</span>)</span><br><span class="line">  <span class="comment">// 序列化管理器</span></span><br><span class="line">  <span class="keyword">val</span> serializerManager = <span class="keyword">new</span> <span class="type">SerializerManager</span>(serializer, conf, ioEncryptionKey)</span><br><span class="line">  <span class="keyword">val</span> closureSerializer = <span class="keyword">new</span> <span class="type">JavaSerializer</span>(conf)</span><br><span class="line">  <span class="comment">// 广播管理器</span></span><br><span class="line">  <span class="keyword">val</span> broadcastManager = <span class="keyword">new</span> <span class="type">BroadcastManager</span>(isDriver, conf, securityManager)</span><br><span class="line">  <span class="comment">// map信息跟踪处理</span></span><br><span class="line">  <span class="keyword">val</span> mapOutputTracker = <span class="keyword">if</span> (isDriver) &#123;</span><br><span class="line">    <span class="keyword">new</span> <span class="type">MapOutputTrackerMaster</span>(conf, broadcastManager, isLocal)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">new</span> <span class="type">MapOutputTrackerWorker</span>(conf)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// shuffle管理器</span></span><br><span class="line">  <span class="keyword">val</span> shuffleManager = instantiateClass[<span class="type">ShuffleManager</span>](shuffleMgrClass)</span><br><span class="line">      <span class="keyword">val</span> memoryManager: <span class="type">MemoryManager</span> =</span><br><span class="line">    <span class="keyword">if</span> (useLegacyMemoryManager) &#123;</span><br><span class="line">      <span class="keyword">new</span> <span class="type">StaticMemoryManager</span>(conf, numUsableCores)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="type">UnifiedMemoryManager</span>(conf, numUsableCores)</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">// 块管理器</span></span><br><span class="line">  <span class="keyword">val</span> blockManager = <span class="keyword">new</span> <span class="type">BlockManager</span>(executorId, rpcEnv, blockManagerMaster,</span><br><span class="line">    serializerManager, conf, memoryManager, mapOutputTracker, shuffleManager,</span><br><span class="line">    blockTransferService, securityManager, numUsableCores)</span><br><span class="line">  <span class="comment">// 度量系统</span></span><br><span class="line">  <span class="keyword">val</span> metricsSystem = <span class="keyword">if</span> (isDriver) &#123;</span><br><span class="line">    <span class="type">MetricsSystem</span>.createMetricsSystem(<span class="string">&quot;driver&quot;</span>, conf, securityManager)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    conf.set(<span class="string">&quot;spark.executor.id&quot;</span>, executorId)</span><br><span class="line">    <span class="keyword">val</span> ms = <span class="type">MetricsSystem</span>.createMetricsSystem(<span class="string">&quot;executor&quot;</span>, conf, securityManager)</span><br><span class="line">    ms.start()</span><br><span class="line">    ms</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 判断是否可以将任务提交到hdfs的权限</span></span><br><span class="line">  <span class="keyword">val</span> outputCommitCoordinator = mockOutputCommitCoordinator.getOrElse &#123;</span><br><span class="line">    <span class="keyword">new</span> <span class="type">OutputCommitCoordinator</span>(conf, isDriver)</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="SerializerManager"><a href="#SerializerManager" class="headerlink" title="SerializerManager"></a>SerializerManager</h3><p>Spark中很多对象在通过网络传输或者写入存储体系时，都需要序列化。SparkEnv中有两个序列化的组件，分别是SerializerManager和closureSerializer。</p>
<p>这里创建的serializer默认为org.apache.spark.serializer.JavaSerializer，用户可以通过spark.serializer属性配置其他的序列化实现，如org.apache.spark.serializer.Kryo-Serializer。closureSerializer的实际类型固定为org.apache.spark.serializer.JavaSerializer，用户不能够自己指定。</p>
<p>需要注意的是Kryo序列化器比Java默认的序列化器更好用，但是它并不支持所有的Serializable对象，使用时需要手动指定并注册需要序列化的类</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="type">SparkConf</span>()</span><br><span class="line">        .setAppName(<span class="string">&quot;Test&quot;</span>)</span><br><span class="line">        .set(<span class="string">&quot;spark.serializer&quot;</span>, <span class="string">&quot;org.apache.spark.serializer.KryoSerializer&quot;</span>)</span><br><span class="line">        .registerKryoClasses(<span class="type">Array</span>(</span><br><span class="line">          classOf[<span class="type">String</span>],</span><br><span class="line">          classOf[<span class="type">Array</span>[<span class="type">String</span>]],</span><br><span class="line">          classOf[<span class="type">GeneralMatcher</span>],</span><br><span class="line">          classOf[<span class="type">Map</span>[<span class="type">Int</span>, <span class="type">String</span>]]</span><br><span class="line">        ))</span><br></pre></td></tr></table></figure>

<p>从源码中可以看到Spark默认对广播对象、Shuffle输出数据和溢出到磁盘的Shuffle的数据都是进行压缩的，而对RDD默认是不压缩的，默认的CompressionCodec是lz4</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Whether to compress broadcast variables that are stored</span></span><br><span class="line"><span class="keyword">private</span>[<span class="keyword">this</span>] <span class="keyword">val</span> compressBroadcast = conf.getBoolean(<span class="string">&quot;spark.broadcast.compress&quot;</span>, <span class="literal">true</span>)</span><br><span class="line"><span class="comment">// Whether to compress shuffle output that are stored</span></span><br><span class="line"><span class="keyword">private</span>[<span class="keyword">this</span>] <span class="keyword">val</span> compressShuffle = conf.getBoolean(<span class="string">&quot;spark.shuffle.compress&quot;</span>, <span class="literal">true</span>)</span><br><span class="line"><span class="comment">// Whether to compress RDD partitions that are stored serialized</span></span><br><span class="line"><span class="keyword">private</span>[<span class="keyword">this</span>] <span class="keyword">val</span> compressRdds = conf.getBoolean(<span class="string">&quot;spark.rdd.compress&quot;</span>, <span class="literal">false</span>)</span><br><span class="line"><span class="comment">// Whether to compress shuffle output temporarily spilled to disk</span></span><br><span class="line"><span class="keyword">private</span>[<span class="keyword">this</span>] <span class="keyword">val</span> compressShuffleSpill = conf.getBoolean(<span class="string">&quot;spark.shuffle.spill.compress&quot;</span>, <span class="literal">true</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">lazy</span> <span class="keyword">val</span> compressionCodec: <span class="type">CompressionCodec</span> = <span class="type">CompressionCodec</span>.createCodec(conf)  <span class="comment">// lz4</span></span><br></pre></td></tr></table></figure>
<p>它提供了对Block输入输出的压缩和加密，对Block输出流的序列化以及输入流的反序列化等方法</p>
<h3 id="BroadcastManager"><a href="#BroadcastManager" class="headerlink" title="BroadcastManager"></a>BroadcastManager</h3><p>Broadcast在实例化时就会调用自身的initialize方法，通过initialized属性判断TorrentBroadcastFactory是否已经实例化，另外两个成员方法分别是newBroadcast用来创建TorrentBroadcast实例，unbroadcast用来取消广播变量。</p>
<p>调用TorrentBroadcastFactory的newBroadcast方法时就会调用它的writeBlocks方法，它将需要广播的数据使用BlockManager写到Driver和Executor上。需要读取广播中的数据调用getValue方法，它调用私有的readBroadcastBlock方法。</p>
<p>writeBlocks</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">def</span> <span class="title">writeBlocks</span></span>(value: <span class="type">T</span>): <span class="type">Int</span> = &#123;</span><br><span class="line">  <span class="keyword">import</span> <span class="type">StorageLevel</span>._</span><br><span class="line">  <span class="comment">// Store a copy of the broadcast variable in the driver so that tasks run on the driver</span></span><br><span class="line">  <span class="comment">// do not create a duplicate copy of the broadcast variable&#x27;s value.</span></span><br><span class="line">  <span class="keyword">val</span> blockManager = <span class="type">SparkEnv</span>.get.blockManager</span><br><span class="line">  <span class="comment">// 将广播对象写入本地存储体系</span></span><br><span class="line">  <span class="keyword">if</span> (!blockManager.putSingle(broadcastId, value, <span class="type">MEMORY_AND_DISK</span>, tellMaster = <span class="literal">false</span>)) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">SparkException</span>(<span class="string">s&quot;Failed to store <span class="subst">$broadcastId</span> in BlockManager&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 将广播对象转换为多个块，块大小默认为4M</span></span><br><span class="line">  <span class="keyword">val</span> blocks =</span><br><span class="line">    <span class="type">TorrentBroadcast</span>.blockifyObject(value, blockSize, <span class="type">SparkEnv</span>.get.serializer, compressionCodec)</span><br><span class="line">  <span class="keyword">if</span> (checksumEnabled) &#123;</span><br><span class="line">    checksums = <span class="keyword">new</span> <span class="type">Array</span>[<span class="type">Int</span>](blocks.length)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 遍历每一个块</span></span><br><span class="line">  blocks.zipWithIndex.foreach &#123; <span class="keyword">case</span> (block, i) =&gt;</span><br><span class="line">    <span class="keyword">if</span> (checksumEnabled) &#123;</span><br><span class="line">      checksums(i) = calcChecksum(block)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">val</span> pieceId = <span class="type">BroadcastBlockId</span>(id, <span class="string">&quot;piece&quot;</span> + i)</span><br><span class="line">    <span class="keyword">val</span> bytes = <span class="keyword">new</span> <span class="type">ChunkedByteBuffer</span>(block.duplicate())</span><br><span class="line">    <span class="comment">// 以序列化的方式将块写入driver和executor</span></span><br><span class="line">    <span class="keyword">if</span> (!blockManager.putBytes(pieceId, bytes, <span class="type">MEMORY_AND_DISK_SER</span>, tellMaster = <span class="literal">true</span>)) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">SparkException</span>(<span class="string">s&quot;Failed to store <span class="subst">$pieceId</span> of <span class="subst">$broadcastId</span> in local BlockManager&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  blocks.length</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>readBroadcastBlock</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">def</span> <span class="title">readBroadcastBlock</span></span>(): <span class="type">T</span> = <span class="type">Utils</span>.tryOrIOException &#123;</span><br><span class="line">  <span class="type">TorrentBroadcast</span>.synchronized &#123;</span><br><span class="line">    setConf(<span class="type">SparkEnv</span>.get.conf)</span><br><span class="line">    <span class="keyword">val</span> blockManager = <span class="type">SparkEnv</span>.get.blockManager</span><br><span class="line">    <span class="comment">// 首先从本地找广播变量</span></span><br><span class="line">    blockManager.getLocalValues(broadcastId).map(_.data.next()) <span class="keyword">match</span> &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="type">Some</span>(x) =&gt;</span><br><span class="line">        <span class="comment">// 如果可以获取到则加锁并返回该对象</span></span><br><span class="line">        releaseLock(broadcastId)</span><br><span class="line">        x.asInstanceOf[<span class="type">T</span>]</span><br><span class="line"></span><br><span class="line">      <span class="keyword">case</span> <span class="type">None</span> =&gt;</span><br><span class="line">        logInfo(<span class="string">&quot;Started reading broadcast variable &quot;</span> + id)</span><br><span class="line">        <span class="keyword">val</span> startTimeMs = <span class="type">System</span>.currentTimeMillis()</span><br><span class="line">        <span class="comment">// 本地获取不到则到driver和executor获取块</span></span><br><span class="line">        <span class="keyword">val</span> blocks = readBlocks().flatMap(_.getChunks())</span><br><span class="line">        logInfo(<span class="string">&quot;Reading broadcast variable &quot;</span> + id + <span class="string">&quot; took&quot;</span> + <span class="type">Utils</span>.getUsedTimeMs(startTimeMs))</span><br><span class="line">        <span class="comment">// 将获取到的块再转换回原来的对象</span></span><br><span class="line">        <span class="keyword">val</span> obj = <span class="type">TorrentBroadcast</span>.unBlockifyObject[<span class="type">T</span>](</span><br><span class="line">          blocks, <span class="type">SparkEnv</span>.get.serializer, compressionCodec)</span><br><span class="line">        <span class="comment">// Store the merged copy in BlockManager so other tasks on this executor don&#x27;t</span></span><br><span class="line">        <span class="comment">// need to re-fetch it.</span></span><br><span class="line">        <span class="keyword">val</span> storageLevel = <span class="type">StorageLevel</span>.<span class="type">MEMORY_AND_DISK</span></span><br><span class="line">        <span class="comment">// 最后再将原来的对象写入到本地的存储体系</span></span><br><span class="line">        <span class="keyword">if</span> (!blockManager.putSingle(broadcastId, obj, storageLevel, tellMaster = <span class="literal">false</span>)) &#123;</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">SparkException</span>(<span class="string">s&quot;Failed to store <span class="subst">$broadcastId</span> in BlockManager&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        obj</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<div align=center><img src="readBroadcast.jpg"></div>

<h3 id="MapOutputTracker"><a href="#MapOutputTracker" class="headerlink" title="MapOutputTracker"></a>MapOutputTracker</h3><p>mapOutputTracker用于跟踪map任务的输出状态，此状态便于reduce任务定位map输出结果所在的节点地址，进而获取中间输出结果。每个map任务或者reduce任务都会有其唯一标识，分别为mapId和reduceId。每个reduce任务的输入可能是多个map任务的输出，reduce会到各个map任务所在的节点上拉取Block，这一过程叫做Shuffle。每次Shuffle都有唯一的标识shuffleId。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注册或查找MapOutputTrackerEndpoint</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">registerOrLookupEndpoint</span></span>(</span><br><span class="line">    name: <span class="type">String</span>, endpointCreator: =&gt; <span class="type">RpcEndpoint</span>):</span><br><span class="line">  <span class="type">RpcEndpointRef</span> = &#123;</span><br><span class="line">  <span class="keyword">if</span> (isDriver) &#123;</span><br><span class="line">    logInfo(<span class="string">&quot;Registering &quot;</span> + name)</span><br><span class="line">    rpcEnv.setupEndpoint(name, endpointCreator)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="type">RpcUtils</span>.makeDriverRef(name, conf, rpcEnv)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Driver则创建MapOutputTrackerMaster，Executor则创建MapOutputTrackerWorker</span></span><br><span class="line"><span class="keyword">val</span> mapOutputTracker = <span class="keyword">if</span> (isDriver) &#123;</span><br><span class="line">  <span class="keyword">new</span> <span class="type">MapOutputTrackerMaster</span>(conf, broadcastManager, isLocal)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="keyword">new</span> <span class="type">MapOutputTrackerWorker</span>(conf)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// trackerEndpoint属性持有MapOutputTrackerMasterEndpoint</span></span><br><span class="line">mapOutputTracker.trackerEndpoint = registerOrLookupEndpoint(<span class="type">MapOutputTracker</span>.<span class="type">ENDPOINT_NAME</span>,</span><br><span class="line">  <span class="keyword">new</span> <span class="type">MapOutputTrackerMasterEndpoint</span>(</span><br><span class="line">    rpcEnv, mapOutputTracker.asInstanceOf[<span class="type">MapOutputTrackerMaster</span>], conf))</span><br></pre></td></tr></table></figure>

<p>可以看到针对当前实例是Driver还是Executor，创建mapOutputTracker的方式有所不同。</p>
<ul>
<li>如果当前应用程序是Driver，则创建MapOutputTrackerMaster，然后创建MapOutputTrackerMasterEndpoint，并且注册到Dispatcher中，注册名为MapOutputTracker。</li>
<li>如果当前应用程序是Executor，则创建MapOutputTrackerWorker，并从远端Driver实例的NettyRpcEnv的Dispatcher中查找MapOutputTrackerMasterEndpoint的引用。<br>无论是Driver还是Executor，最后都由mapOutputTracker的属性trackerEndpoint持有MapOutputTrackerMasterEndpoint的引用</li>
</ul>
<p>重点看一下MapOutputTracker中获取map状态信息的方法getStatuses</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">def</span> <span class="title">getStatuses</span></span>(shuffleId: <span class="type">Int</span>): <span class="type">Array</span>[<span class="type">MapStatus</span>] = &#123;</span><br><span class="line">  <span class="keyword">val</span> statuses = mapStatuses.get(shuffleId).orNull</span><br><span class="line">  <span class="comment">// 从当前MapOutputTracker的mapstatuses缓存中获取MapStatus数组，有的话直接返回</span></span><br><span class="line">  <span class="keyword">if</span> (statuses == <span class="literal">null</span>) &#123;</span><br><span class="line">    logInfo(<span class="string">&quot;Don&#x27;t have map outputs for shuffle &quot;</span> + shuffleId + <span class="string">&quot;, fetching them&quot;</span>)</span><br><span class="line">    <span class="keyword">val</span> startTime = <span class="type">System</span>.currentTimeMillis</span><br><span class="line">    <span class="keyword">var</span> fetchedStatuses: <span class="type">Array</span>[<span class="type">MapStatus</span>] = <span class="literal">null</span></span><br><span class="line">    <span class="comment">// 因为可能有多个线程获取，所以必须设为线程安全的操作</span></span><br><span class="line">    fetching.synchronized &#123;</span><br><span class="line">      <span class="comment">// fetching存储正在获取map信息的shuffleId，说明其他线程正在获取，当前线程等待即可</span></span><br><span class="line">      <span class="keyword">while</span> (fetching.contains(shuffleId)) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          fetching.wait()</span><br><span class="line">        &#125; <span class="keyword">catch</span> &#123;</span><br><span class="line">          <span class="keyword">case</span> e: <span class="type">InterruptedException</span> =&gt;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 这里有两种情况，第一种情况是第一个进来的线程走到这并把shuffleId放入fetching；</span></span><br><span class="line">      <span class="comment">// 第二种情况是后来的线程在线程解除等待后走到这，此时fetchedStatuses可能已被第一个线程放入对应的map信息</span></span><br><span class="line">      fetchedStatuses = mapStatuses.get(shuffleId).orNull</span><br><span class="line">      <span class="keyword">if</span> (fetchedStatuses == <span class="literal">null</span>) &#123;</span><br><span class="line">        fetching += shuffleId</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第一个线程执行里面的操作</span></span><br><span class="line">    <span class="keyword">if</span> (fetchedStatuses == <span class="literal">null</span>) &#123;</span><br><span class="line">      logInfo(<span class="string">&quot;Doing the fetch; tracker endpoint = &quot;</span> + trackerEndpoint)</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// askTracker向MapOutputTrackerMasterEndpoint发送GetMapOutputStatuses消息，以获取map任务的状态信息</span></span><br><span class="line">        <span class="keyword">val</span> fetchedBytes = askTracker[<span class="type">Array</span>[<span class="type">Byte</span>]](<span class="type">GetMapOutputStatuses</span>(shuffleId))</span><br><span class="line">        <span class="comment">// 请求方接收到map任务状态信息后，调用MapOutputTracker的deserializeMapStatuses方法对map任务状态进行反序列化操作，然后放入本地的mapStatuses缓存中</span></span><br><span class="line">        fetchedStatuses = <span class="type">MapOutputTracker</span>.deserializeMapStatuses(fetchedBytes)</span><br><span class="line">        logInfo(<span class="string">&quot;Got the output locations&quot;</span>)</span><br><span class="line">        mapStatuses.put(shuffleId, fetchedStatuses)</span><br><span class="line">      &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 不管这次是否获取到map信息，都需要把shuffleId从fetching移除并唤醒其他正在等待的线程，如果获取失败后续线程会继续执行上面的操作</span></span><br><span class="line">        fetching.synchronized &#123;</span><br><span class="line">          fetching -= shuffleId</span><br><span class="line">          fetching.notifyAll()</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    logDebug(<span class="string">s&quot;Fetching map output statuses for shuffle <span class="subst">$shuffleId</span> took &quot;</span> +</span><br><span class="line">      <span class="string">s&quot;<span class="subst">$&#123;System.currentTimeMillis - startTime&#125;</span> ms&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果获取到的话就直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (fetchedStatuses != <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> fetchedStatuses</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      logError(<span class="string">&quot;Missing all output locations for shuffle &quot;</span> + shuffleId)</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">MetadataFetchFailedException</span>(</span><br><span class="line">        shuffleId, <span class="number">-1</span>, <span class="string">&quot;Missing all output locations for shuffle &quot;</span> + shuffleId)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 后续线程直接从当前MapOuputTracker的mapStatuses缓存中获取对应的map信息</span></span><br><span class="line">    <span class="keyword">return</span> statuses</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="MapOutputTrackerMaster"><a href="#MapOutputTrackerMaster" class="headerlink" title="MapOutputTrackerMaster"></a>MapOutputTrackerMaster</h4><p>接下来重点看一下MapOutputTrackerMaster，它提供了获取map信息的具体实现方法，也就是<code>askTracker[Array[Byte]](GetMapOutputStatuses(shuffleId))</code>的具体实现</p>
<p>MapOutputTrackerMaster的几个重要属性：</p>
<ul>
<li>mapStatuses：用于存储shuffleId与Array[MapStatus]的映射关系。由于MapStatus维护了map输出Block的地址BlockManagerId，所以reduce任务知道从何处获取map任务的中间输出</li>
<li>cachedSerializedStatuses：用于存储shuffleId与序列化后的状态的映射关系。其中key对应shuffleId, value为对MapStatus序列化后的字节数组。</li>
<li>mapOutputRequests：使用阻塞队列来缓存GetMapOutputMessage（获取map任务输出）的请求</li>
<li>threadpool：用于获取map输出的固定大小的线程池。此线程池提交的线程都以后台线程运行，且线程名以map-output-dispatcher为前缀，线程池大小可以使用spark.shuffle.mapOutput.dispatcher.numThreads属性配置，默认大小为8</li>
</ul>
<p>在创建MapOutputTrackerMaster的最后，会创建对map输出请求进行处理的线程池threadpool，它里面有固定数量的线程处理Executor发送过来的获取map信息的请求</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> threadpool: <span class="type">ThreadPoolExecutor</span> = &#123;</span><br><span class="line">  <span class="keyword">val</span> numThreads = conf.getInt(<span class="string">&quot;spark.shuffle.mapOutput.dispatcher.numThreads&quot;</span>, <span class="number">8</span>)</span><br><span class="line">  <span class="keyword">val</span> pool = <span class="type">ThreadUtils</span>.newDaemonFixedThreadPool(numThreads, <span class="string">&quot;map-output-dispatcher&quot;</span>)</span><br><span class="line">  <span class="keyword">for</span> (i &lt;- <span class="number">0</span> until numThreads) &#123;</span><br><span class="line">    <span class="comment">// 启动与线程池大小相同数量的线程，每个线程执行的任务都是MessageLoop</span></span><br><span class="line">    pool.execute(<span class="keyword">new</span> <span class="type">MessageLoop</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  pool</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// MessageLoop实现了Java的Runnable接口</span></span><br><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">MessageLoop</span> <span class="keyword">extends</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">run</span></span>(): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="comment">// 从mapOutputRequests中获取GetMapOutputMessage</span></span><br><span class="line">          <span class="comment">// 由于mapOutputRequests是个阻塞队列，所以当mapOutputRequests中没有GetMapOutputMessage时，MessageLoop线程会被阻塞</span></span><br><span class="line">          <span class="comment">// GetMapOutputMessage是个样例类，包含了shuffleId和RpcCallContext两个属性</span></span><br><span class="line">          <span class="keyword">val</span> data = mapOutputRequests.take()</span><br><span class="line">          <span class="comment">// 如果取到的GetMapOutputMessage是PoisonPill（“毒药”），那么此MessageLoop线程将退出（通过return语句）</span></span><br><span class="line">          <span class="comment">// 随后将PoisonPill重新放入到mapOutput-Requests中，这是因为threadpool线程池极有可能不止一个MessageLoop线程，为了让大家都“毒发身亡”，还需要把“毒药”放回到receivers中，这样其他“活着”的线程就会再次误食“毒药”，达到所有MessageLoop线程都结束的效果</span></span><br><span class="line">           <span class="keyword">if</span> (data == <span class="type">PoisonPill</span>) &#123;</span><br><span class="line">            mapOutputRequests.offer(<span class="type">PoisonPill</span>)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">val</span> context = data.context</span><br><span class="line">          <span class="keyword">val</span> shuffleId = data.shuffleId</span><br><span class="line">          <span class="keyword">val</span> hostPort = context.senderAddress.hostPort</span><br><span class="line">          logDebug(<span class="string">&quot;Handling request to send map output locations for shuffle &quot;</span> + shuffleId +</span><br><span class="line">            <span class="string">&quot; to &quot;</span> + hostPort)</span><br><span class="line">          <span class="comment">// 调用getSerializedMapOutputStatuses方法获取GetMapOutputMessage携带的shuffleId所对应的序列化任务状态信息</span></span><br><span class="line">          <span class="keyword">val</span> mapOutputStatuses = getSerializedMapOutputStatuses(shuffleId)</span><br><span class="line">          <span class="comment">// 调用RpcCallContext的回调方法reply，将序列化的map任务状态信息返回给客户端（即其他节点的Executor）</span></span><br><span class="line">          context.reply(mapOutputStatuses)</span><br><span class="line">        &#125; <span class="keyword">catch</span> &#123;</span><br><span class="line">          <span class="keyword">case</span> <span class="type">NonFatal</span>(e) =&gt; logError(e.getMessage, e)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> &#123;</span><br><span class="line">      <span class="keyword">case</span> ie: <span class="type">InterruptedException</span> =&gt; <span class="comment">// exit</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后主要通过调用MapOutputTrackerMaster的post方法将GetMapOutputMessage放入mapOutputRequests</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">post</span></span>(message: <span class="type">GetMapOutputMessage</span>): <span class="type">Unit</span> = &#123;</span><br><span class="line">  mapOutputRequests.offer(message)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>MapOutputTrackerMaster的运行原理</p>
<div align=center><img src="MapOutputTrackerMaster.jpg"></div>

<ol>
<li>表示某个Executor调用MapOutputTrackerWorker的getStatuses方法获取某个shuffle的map任务状态信息，当发现本地的mapStatuses没有相应的缓存，则调用askTracker方法发送GetMapOutputStatuses消息。askTracker实际是通过MapOutputTrackerMasterEndpoint的NettyRpcEndpointRef向远端发送GetMapOutputStatuses消息。发送实际依托于NettyRpcEndpointRef持有的TransportClient。MapOutputTrackerMasterEndpoint在接收到GetMapOutputStatuses消息后，将GetMapOutputMessage消息放入mapOutput Requests队尾</li>
<li>表示MessageLoop线程从mapOutputRequests队头取出GetMapOutputMessage</li>
<li>表示从shuffleIdLocks数组中取出与当前GetMapOutputMessage携带的shuffleId相对应的锁</li>
<li>表示首先从cachedSerializedStatuses缓存中获取shuffleId对应的序列化任务状态信息</li>
<li>表示当cachedSerializedStatuses中没有shuffleId对应的序列化任务状态信息，则获取mapStatuses中缓存的shuffleId对应的任务状态数组</li>
<li>表示将任务状态数组进行序列化，然后使用BroadcastManager对序列化的任务状态进行广播</li>
<li>表示将序列化的任务状态放入cachedSerializedStatuses缓存中</li>
<li>表示将广播对象放入cachedSerializedBroadcast缓存中</li>
<li>表示将获得的序列化任务状态信息，通过回调GetMapOutputMessage消息携带的RpcCallContext的reply方法回复客户端</li>
</ol>
<h4 id="Shuffle注册"><a href="#Shuffle注册" class="headerlink" title="Shuffle注册"></a>Shuffle注册</h4><p>DAGScheduler在创建ShuffleMapStage的时候，将调用Map-OutputTrackerMaster的containsShuffle方法，查看是否已经存在shuffleId对应的MapStatus。如果MapOutputTrackerMaster中未注册此shuffleId，那么调用MapOutput-TrackerMaster的registerShuffle方法注册shuffleId</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 查询ShuffleId是否被跟踪</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">containsShuffle</span></span>(shuffleId: <span class="type">Int</span>): <span class="type">Boolean</span> = &#123;</span><br><span class="line">  cachedSerializedStatuses.contains(shuffleId) || mapStatuses.contains(shuffleId)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注册一个MapStatuses为空的ShuffleId</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">registerShuffle</span></span>(shuffleId: <span class="type">Int</span>, numMaps: <span class="type">Int</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (mapStatuses.put(shuffleId, <span class="keyword">new</span> <span class="type">Array</span>[<span class="type">MapStatus</span>](numMaps)).isDefined) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">IllegalArgumentException</span>(<span class="string">&quot;Shuffle ID &quot;</span> + shuffleId + <span class="string">&quot; registered twice&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// add in advance</span></span><br><span class="line">  shuffleIdLocks.putIfAbsent(shuffleId, <span class="keyword">new</span> <span class="type">Object</span>())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// </span></span><br></pre></td></tr></table></figure>

<p>当ShuffleMapStage内的所有ShuffleMapTask运行成功后，将调用MapOutputTrackerMaster的registerMapOutputs方法。registerMapOutputs方法将把ShuffleMapStage中每个Shuffle-MapTask的MapStatus保存到shuffleId在mapStatuses中对应的数组中</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">registerMapOutputs</span></span>(shuffleId: <span class="type">Int</span>, statuses: <span class="type">Array</span>[<span class="type">MapStatus</span>], changeEpoch: <span class="type">Boolean</span> = <span class="literal">false</span>) &#123;</span><br><span class="line">  mapStatuses.put(shuffleId, statuses.clone())</span><br><span class="line">  <span class="keyword">if</span> (changeEpoch) &#123;</span><br><span class="line">    incrementEpoch()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="构建存储体系"><a href="#构建存储体系" class="headerlink" title="构建存储体系"></a>构建存储体系</h3><p>存储体系。存储体系中最重要的组件包括Shuffle管理器ShuffleManager、内存管理器MemoryManager、块传输服务BlockTransferService、对所有BlockManager进行管理的BlockManagerMaster、磁盘块管理器DiskBlockManager、块锁管理器BlockInfoManager及块管理器BlockManager，这里只看各个组件的实例化，详细的内容在其他文章中说明</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> shortShuffleMgrNames = <span class="type">Map</span>(</span><br><span class="line">  <span class="string">&quot;sort&quot;</span> -&gt; classOf[org.apache.spark.shuffle.sort.<span class="type">SortShuffleManager</span>].getName,</span><br><span class="line">  <span class="string">&quot;tungsten-sort&quot;</span> -&gt; classOf[org.apache.spark.shuffle.sort.<span class="type">SortShuffleManager</span>].getName)</span><br><span class="line"><span class="keyword">val</span> shuffleMgrName = conf.get(<span class="string">&quot;spark.shuffle.manager&quot;</span>, <span class="string">&quot;sort&quot;</span>)</span><br><span class="line"><span class="keyword">val</span> shuffleMgrClass = shortShuffleMgrNames.getOrElse(shuffleMgrName.toLowerCase, shuffleMgrName)</span><br><span class="line"><span class="keyword">val</span> shuffleManager = instantiateClass[<span class="type">ShuffleManager</span>](shuffleMgrClass)</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> useLegacyMemoryManager = conf.getBoolean(<span class="string">&quot;spark.memory.useLegacyMode&quot;</span>, <span class="literal">false</span>)</span><br><span class="line"><span class="keyword">val</span> memoryManager: <span class="type">MemoryManager</span> =</span><br><span class="line">  <span class="keyword">if</span> (useLegacyMemoryManager) &#123;</span><br><span class="line">    <span class="keyword">new</span> <span class="type">StaticMemoryManager</span>(conf, numUsableCores)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="type">UnifiedMemoryManager</span>(conf, numUsableCores)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> blockManagerPort = <span class="keyword">if</span> (isDriver) &#123;</span><br><span class="line">  conf.get(<span class="type">DRIVER_BLOCK_MANAGER_PORT</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  conf.get(<span class="type">BLOCK_MANAGER_PORT</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> blockTransferService =</span><br><span class="line">  <span class="keyword">new</span> <span class="type">NettyBlockTransferService</span>(conf, securityManager, bindAddress, advertiseAddress,</span><br><span class="line">    blockManagerPort, numUsableCores)</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> blockManagerMaster = <span class="keyword">new</span> <span class="type">BlockManagerMaster</span>(registerOrLookupEndpoint(</span><br><span class="line">  <span class="type">BlockManagerMaster</span>.<span class="type">DRIVER_ENDPOINT_NAME</span>,</span><br><span class="line">  <span class="keyword">new</span> <span class="type">BlockManagerMasterEndpoint</span>(rpcEnv, isLocal, conf, listenerBus)),</span><br><span class="line">  conf, isDriver)</span><br><span class="line"></span><br><span class="line"><span class="comment">// NB: blockManager is not valid until initialize() is called later.</span></span><br><span class="line"><span class="keyword">val</span> blockManager = <span class="keyword">new</span> <span class="type">BlockManager</span>(executorId, rpcEnv, blockManagerMaster,</span><br><span class="line">  serializerManager, conf, memoryManager, mapOutputTracker, shuffleManager,</span><br><span class="line">  blockTransferService, securityManager, numUsableCores)</span><br></pre></td></tr></table></figure>

<ol>
<li>根据spark.shuffle.manager属性，实例化ShuffleManager。Spark2.x.x版本提供了sort和tungsten-sort两种ShuffleManager的实现。无论是sort还是tungsten-sort，其实现类都是SortShuffleManager</li>
<li>MemoryManager的主要实现有StaticMemoryManager和UnifiedMemoryManager。StaticMemoryManager是Spark早期版本遗留下来的内存管理器实现，可以配置spark.memory.useLegacyMode属性来指定，该属性默认为false，因此默认的内存管理器是UnifiedMemoryManager</li>
<li>获取当前SparkEnv的块传输服务BlockTransferService对外提供的端口号。如果当前实例是Driver，则从SparkConf中获取由常量DRIVER_BLOCK_MANAGER_PORT指定的端口。如果当前实例是Executor，则从SparkConf中获取由常量BLOCK_MANAGER_PORT指定的端口</li>
<li>创建块传输服务BlockTransferService。这里使用的是BlockTransferService的子类NettyBlockTransferService, NettyBlockTransferService将提供对外的块传输服务。也正是因为MapOutputTracker与NettyBlockTransferService的配合，才实现了Spark的Shuffle</li>
<li>查找或注册BlockManagerMasterEndpoint，这里和MapOutputTracker处理方式相同</li>
</ol>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="mailto:undefined">WangXun</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="https://wangxukun.top/2022/08/11/Software/Spark进阶-SparkContext之SparnEnv/">https://wangxukun.top/2022/08/11/Software/Spark进阶-SparkContext之SparnEnv/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Spark/">Spark</a></div><nav id="pagination"><div class="prev-post pull-left"><a href="/2022/08/19/Mind/%E5%8F%98%E5%8C%96%E6%98%AF%E8%B6%8B%E5%8A%BF%EF%BC%8C%E4%B8%8D%E5%8F%98%E6%98%AF%E5%B8%B8%E6%80%81/"><i class="fa fa-chevron-left">  </i><span>变化是趋势，不变是常态</span></a></div><div class="next-post pull-right"><a href="/2022/04/20/Software/Oozie-%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80/"><span>Oozie-入门基础</span><i class="fa fa-chevron-right"></i></a></div></nav><div id="gitalk-container"></div><script>var gitalk = new Gitalk({
  clientID: 'aaf2844e0aeef4917c17',
  clientSecret: '10b96d24dffda7d3b4544778cf620f81990b676d',
  repo: 'blog-issue',
  owner: 'w749',
  admin: 'w749',
  id: md5(decodeURI(location.pathname)),
  language: 'en'
})
gitalk.render('gitalk-container')</script></div></div><footer class="footer-bg" style="background-image: url(/img/top-img.jpg)"><div class="layout" id="footer"><div class="copyright">&copy;2019 - 2022 By WangXun</div><div class="framework-info"><span>Driven - </span><a target="_blank" rel="noopener" href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme - </span><a target="_blank" rel="noopener" href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="footer_custom_text">hitokoto</div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-eye"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/lib/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.9.1"></script><script src="/js/fancybox.js?version=1.9.1"></script><script src="/js/sidebar.js?version=1.9.1"></script><script src="/js/copy.js?version=1.9.1"></script><script src="/js/fireworks.js?version=1.9.1"></script><script src="/js/transition.js?version=1.9.1"></script><script src="/js/scroll.js?version=1.9.1"></script><script src="/js/head.js?version=1.9.1"></script><script src="/js/search/algolia.js"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script><div class="search-dialog" id="algolia-search"><div class="search-dialog__title" id="algolia-search-title">Algolia</div><div id="algolia-input-panel"><div id="algolia-search-input"></div></div><hr><div id="algolia-search-results"><div id="algolia-hits"></div><div id="algolia-pagination"></div><div id="algolia-stats"></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div></body></html>