<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="Spark进阶-BlockManager"><meta name="keywords" content="Spark"><meta name="author" content="WangXun"><meta name="copyright" content="WangXun"><title>Spark进阶-BlockManager | Wake</title><link rel="shortcut icon" href="/img/favicon-blank.svg"><link rel="stylesheet" href="/css/index.css?version=1.9.1"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.9.1"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/instantsearch.js@2.1.1/dist/instantsearch.min.css"><script src="https://cdn.jsdelivr.net/npm/instantsearch.js@2.1.1/dist/instantsearch.min.js" defer></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.css"><script src="https://cdn.jsdelivr.net/npm/gitalk@latest/dist/gitalk.min.js"></script><script src="https://cdn.jsdelivr.net/npm/blueimp-md5@2.10.0/js/md5.min.js"></script><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script src="https://v1.hitokoto.cn/?encode=js&amp;charset=utf-8&amp;select=.footer_custom_text" defer></script><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: {"appId":"HSM2EINL2X","apiKey":"6f1478b12150efd917d5ecfcddfb8b8b","indexName":"wangxun","hits":{"per_page":10},"languages":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}.","hits_stats":"${hits} results found in ${time} ms"}},
  localSearch: undefined,
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  hexoVersion: '6.0.0'
} </script><meta name="generator" content="Hexo 6.0.0"></head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="true"><div class="toggle-sidebar-info text-center"><span data-toggle="Toggle article">Toggle site</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">Catalog</div><div class="sidebar-toc__progress"><span class="progress-notice">You've read</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#BlockManagerMaster"><span class="toc-number">1.</span> <span class="toc-text">BlockManagerMaster</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#BlockManagerMasterEndpoint"><span class="toc-number">2.</span> <span class="toc-text">BlockManagerMasterEndpoint</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%87%8D%E8%A6%81%E5%B1%9E%E6%80%A7"><span class="toc-number">2.1.</span> <span class="toc-text">重要属性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#BlockManagerMasterEndpoint-register"><span class="toc-number">2.2.</span> <span class="toc-text">BlockManagerMasterEndpoint.register</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A5RemoveBroadcast%E4%B8%BA%E4%BE%8B%E8%B7%9F%E8%B8%AA%E6%B6%88%E6%81%AF%E6%B5%81%E7%A8%8B"><span class="toc-number">2.3.</span> <span class="toc-text">以RemoveBroadcast为例跟踪消息流程</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#BlockManagerStorageEndpoint"><span class="toc-number">3.</span> <span class="toc-text">BlockManagerStorageEndpoint</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#BlockManager"><span class="toc-number">4.</span> <span class="toc-text">BlockManager</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#BlockManager%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">4.1.</span> <span class="toc-text">BlockManager初始化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#write-block"><span class="toc-number">4.2.</span> <span class="toc-text">write block</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#read-block"><span class="toc-number">4.3.</span> <span class="toc-text">read block</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#remove-block"><span class="toc-number">4.4.</span> <span class="toc-text">remove block</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B6%E4%BB%96%E7%BB%84%E4%BB%B6"><span class="toc-number">4.5.</span> <span class="toc-text">其他组件</span></a></li></ol></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="/img/avatar.jpg"></div><div class="author-info__name text-center">WangXun</div><div class="author-info__description text-center"></div><div class="follow-button"><a target="_blank" rel="noopener" href="https://github.com/w749">Follow Me</a></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">Articles</span><span class="pull-right">71</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">Tags</span><span class="pull-right">20</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">Categories</span><span class="pull-right">6</span></a></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(/img/top-img.jpg)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">Wake</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">Home</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/categories">Categories</a></span><span class="pull-right"><a class="site-page social-icon search"><i class="fa fa-search"></i><span> Search</span></a></span></div><div id="post-info"><div id="post-title">Spark进阶-BlockManager</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2022-11-02</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/Software/">Software</a><div class="post-meta-wordcount"><span>Word count: </span><span class="word-count">3.1k</span><span class="post-meta__separator">|</span><span>Reading time: 14 min</span></div></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><p>Spark BlockManager及相关组件和主要运行流程介绍</p>
<span id="more"></span>
<blockquote>
<p>源码版本是Spark 3.1.2</p>
</blockquote>
<h2 id="BlockManagerMaster"><a href="#BlockManagerMaster" class="headerlink" title="BlockManagerMaster"></a>BlockManagerMaster</h2><p>之所以以BlockManagerMaster为起点有两个原因，第一个是因为它的初始化早于BlockManager，第二个是因为它负责将BlockManager的请求操作发送给Driver的BlockManagerMasterEndpoint由它来处理一系列请求，driver和executor都有BlockManagerMaster</p>
<p>它的初始化代码在SparkEnv的create方法中，现在不管是driver还是executor都有自己的BlockManagerMaster，并且都拿到了BlockManagerMaster的RpcEndpointRef和BlockManagerMasterHeartbeat的RpcEndpointRef</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> blockManagerMaster = <span class="keyword">new</span> <span class="type">BlockManagerMaster</span>(</span><br><span class="line">  <span class="comment">// 创建或者查找对应的RpcEndpointRef，如果在driver端则需要注册，如果是executor则通过名称检索对应的RpcEndpointRef。这里返回BlockManagerMaster的RpcEndpointRef</span></span><br><span class="line">  registerOrLookupEndpoint(</span><br><span class="line">    <span class="type">BlockManagerMaster</span>.<span class="type">DRIVER_ENDPOINT_NAME</span>,</span><br><span class="line">    <span class="keyword">new</span> <span class="type">BlockManagerMasterEndpoint</span>(</span><br><span class="line">      rpcEnv,</span><br><span class="line">      isLocal,</span><br><span class="line">      conf,</span><br><span class="line">      listenerBus,</span><br><span class="line">      <span class="keyword">if</span> (conf.get(config.<span class="type">SHUFFLE_SERVICE_FETCH_RDD_ENABLED</span>)) &#123;</span><br><span class="line">        externalShuffleClient</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="type">None</span></span><br><span class="line">      &#125;, blockManagerInfo,</span><br><span class="line">      mapOutputTracker.asInstanceOf[<span class="type">MapOutputTrackerMaster</span>])),</span><br><span class="line">  <span class="comment">// 返回BlockManagerMasterHeartbeat的RpcEndpointRef，不重点关注</span></span><br><span class="line">  registerOrLookupEndpoint(</span><br><span class="line">    <span class="type">BlockManagerMaster</span>.<span class="type">DRIVER_HEARTBEAT_ENDPOINT_NAME</span>,</span><br><span class="line">    <span class="keyword">new</span> <span class="type">BlockManagerMasterHeartbeatEndpoint</span>(rpcEnv, isLocal, blockManagerInfo)),</span><br><span class="line">  conf,</span><br><span class="line">  isDriver)</span><br></pre></td></tr></table></figure>

<h2 id="BlockManagerMasterEndpoint"><a href="#BlockManagerMasterEndpoint" class="headerlink" title="BlockManagerMasterEndpoint"></a>BlockManagerMasterEndpoint</h2><p>它是的作用是跟踪并保存BlockManager的状态，处理由BlockManagerMaster发送来的一些操作请求并返回所需的状态数据，例如GetLocations（获取指定blockId位置）、RemoveBroadcast（从各BlockManager移除广播变量）等等。当然它只是个中转站，用来解析请求内容并将它发送给其他的BlockManager（driver或者executor）去处理</p>
<h3 id="重要属性"><a href="#重要属性" class="headerlink" title="重要属性"></a>重要属性</h3><ul>
<li>blockManagerInfo: mutable.Map[BlockManagerId, BlockManagerInfo] 维护BlockManagerId和BlockManagerInfo的关系，初始化时它是空的</li>
<li>executorIdToLocalDirs: Cache[String, Array[String]] 维护executorId和localDirs的映射关系</li>
<li>blockManagerIdByExecutor: mutable.HashMap[String, BlockManagerId] 维护executorId和BlockManagerId的映射关系</li>
<li>blockLocations: JHashMap[BlockId, mutable.HashSet[BlockManagerId]] 维护blockId对应拥有此block的BlockMangerId的映射关系</li>
</ul>
<h3 id="BlockManagerMasterEndpoint-register"><a href="#BlockManagerMasterEndpoint-register" class="headerlink" title="BlockManagerMasterEndpoint.register"></a>BlockManagerMasterEndpoint.register</h3><p>每个BlockManager都需要在BlockManagerMasterEndpoint注册，来看一下register方法都做了哪些事</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">def</span> <span class="title">register</span></span>(</span><br><span class="line">    idWithoutTopologyInfo: <span class="type">BlockManagerId</span>,</span><br><span class="line">    localDirs: <span class="type">Array</span>[<span class="type">String</span>],</span><br><span class="line">    maxOnHeapMemSize: <span class="type">Long</span>,</span><br><span class="line">    maxOffHeapMemSize: <span class="type">Long</span>,</span><br><span class="line">    storageEndpoint: <span class="type">RpcEndpointRef</span>): <span class="type">BlockManagerId</span> = &#123;</span><br><span class="line">  <span class="comment">// 重新封装BlockManagerId</span></span><br><span class="line">  <span class="keyword">val</span> id = <span class="type">BlockManagerId</span>(</span><br><span class="line">    idWithoutTopologyInfo.executorId,</span><br><span class="line">    idWithoutTopologyInfo.host,</span><br><span class="line">    idWithoutTopologyInfo.port,</span><br><span class="line">    topologyMapper.getTopologyForHost(idWithoutTopologyInfo.host))</span><br><span class="line"></span><br><span class="line">  <span class="keyword">val</span> time = <span class="type">System</span>.currentTimeMillis()</span><br><span class="line">  <span class="comment">// 将executorId和磁盘地址的映射维护到executorIdToLocalDirs</span></span><br><span class="line">  executorIdToLocalDirs.put(id.executorId, localDirs)</span><br><span class="line">  <span class="comment">// register时blockManagerInfo和blockManagerIdByExecutor不能包含相同的id信息</span></span><br><span class="line">  <span class="keyword">if</span> (!blockManagerInfo.contains(id)) &#123;</span><br><span class="line">    blockManagerIdByExecutor.get(id.executorId) <span class="keyword">match</span> &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="type">Some</span>(oldId) =&gt;</span><br><span class="line">        <span class="comment">// A block manager of the same executor already exists, so remove it (assumed dead)</span></span><br><span class="line">        logError(<span class="string">&quot;Got two different block manager registrations on same executor - &quot;</span></span><br><span class="line">            + <span class="string">s&quot; will replace old one <span class="subst">$oldId</span> with new one <span class="subst">$id</span>&quot;</span>)</span><br><span class="line">        removeExecutor(id.executorId)</span><br><span class="line">      <span class="keyword">case</span> <span class="type">None</span> =&gt;</span><br><span class="line">    &#125;</span><br><span class="line">    logInfo(<span class="string">&quot;Registering block manager %s with %s RAM, %s&quot;</span>.format(</span><br><span class="line">      id.hostPort, <span class="type">Utils</span>.bytesToString(maxOnHeapMemSize + maxOffHeapMemSize), id))</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 维护executorId和BlockManagerId</span></span><br><span class="line">    blockManagerIdByExecutor(id.executorId) = id</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> externalShuffleServiceBlockStatus =</span><br><span class="line">      <span class="keyword">if</span> (externalShuffleServiceRddFetchEnabled) &#123;</span><br><span class="line">        <span class="keyword">val</span> externalShuffleServiceBlocks = blockStatusByShuffleService</span><br><span class="line">          .getOrElseUpdate(externalShuffleServiceIdOnHost(id), <span class="keyword">new</span> <span class="type">JHashMap</span>[<span class="type">BlockId</span>, <span class="type">BlockStatus</span>])</span><br><span class="line">        <span class="type">Some</span>(externalShuffleServiceBlocks)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="type">None</span></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 维护BlockManagerId和BlockManagerInfo</span></span><br><span class="line">    blockManagerInfo(id) = <span class="keyword">new</span> <span class="type">BlockManagerInfo</span>(id, <span class="type">System</span>.currentTimeMillis(),</span><br><span class="line">      maxOnHeapMemSize, maxOffHeapMemSize, storageEndpoint, externalShuffleServiceBlockStatus)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pushBasedShuffleEnabled) &#123;</span><br><span class="line">      addMergerLocation(id)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  listenerBus.post(<span class="type">SparkListenerBlockManagerAdded</span>(time, id, maxOnHeapMemSize + maxOffHeapMemSize,</span><br><span class="line">      <span class="type">Some</span>(maxOnHeapMemSize), <span class="type">Some</span>(maxOffHeapMemSize)))</span><br><span class="line">  id</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="以RemoveBroadcast为例跟踪消息流程"><a href="#以RemoveBroadcast为例跟踪消息流程" class="headerlink" title="以RemoveBroadcast为例跟踪消息流程"></a>以RemoveBroadcast为例跟踪消息流程</h3><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">rddBroadcast.unpersist()  <span class="comment">// 程序入口</span></span><br><span class="line">unpersist(blocking = <span class="literal">false</span>)</span><br><span class="line">doUnpersist(blocking)</span><br><span class="line"><span class="type">TorrentBroadcast</span>.doUnpersist(blocking: <span class="type">Boolean</span>)</span><br><span class="line"><span class="type">TorrentBroadcast</span>.unpersist(id, removeFromDriver = <span class="literal">false</span>, blocking)</span><br><span class="line"><span class="comment">// 由driver的BlockManager的BlockManagerMaster发送RemoveBroadcast消息</span></span><br><span class="line"><span class="type">SparkEnv</span>.get.blockManager.master.removeBroadcast(id, removeFromDriver, blocking)</span><br><span class="line"><span class="comment">// 向BlockManagerMasterEndpoint发送RemoveBroadcast消息</span></span><br><span class="line">driverEndpoint.askSync[<span class="type">Future</span>[<span class="type">Seq</span>[<span class="type">Int</span>]]](<span class="type">RemoveBroadcast</span>(broadcastId, removeFromMaster))</span><br><span class="line"><span class="comment">// 消息会被这个方法处理，查看RemoveBroadcast消息的处理方法就行</span></span><br><span class="line"><span class="type">BlockManagerMasterEndpoint</span>.receiveAndReply(context: <span class="type">RpcCallContext</span>)</span><br><span class="line"><span class="type">BlockManagerMasterEndpoint</span>.removeBroadcast(broadcastId: <span class="type">Long</span>, removeFromDriver: <span class="type">Boolean</span>)</span><br><span class="line"><span class="comment">// BlockManagerMasterEndpoint处理不了，将它发送给BlockManagerStorageEndpoint，BlockManagerStorageEndpoint相关介绍往下看</span></span><br><span class="line">bm.storageEndpoint.ask[<span class="type">Int</span>](removeMsg).recover</span><br><span class="line"><span class="type">BlockManagerStorageEndpoint</span>.receiveAndReply(context: <span class="type">RpcCallContext</span>)</span><br><span class="line">blockManager.removeBroadcast(broadcastId, tellMaster = <span class="literal">true</span>)  <span class="comment">// 最终它会调用对应BlockManager的removeBroadcast方法</span></span><br></pre></td></tr></table></figure>
<p>例如RegisterBlockManager、GetLocations这些消息BlockManagerMasterEndpoint可以处理，因为所有的BlockManager都在它这注册，所以它自己处理完之后就可以返回，类似移除Block、移除Shuffle都由各自Executor的BlockManager完成所有发送给对应的BlockManagerStorageEndpoint</p>
<h2 id="BlockManagerStorageEndpoint"><a href="#BlockManagerStorageEndpoint" class="headerlink" title="BlockManagerStorageEndpoint"></a>BlockManagerStorageEndpoint</h2><p>它的作用是接收从BlockManagerMasterEndpoint接收消息并在自己对应的BlockManager执行对应的操作，例如上面的RemoveBroadcast，它和BlockManager是一对一对应的。下面看一下它的初始化</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 它的初始化在BlockManager实例化过程中已经完成</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> storageEndpoint = rpcEnv.setupEndpoint(</span><br><span class="line">  <span class="string">&quot;BlockManagerEndpoint&quot;</span> + <span class="type">BlockManager</span>.<span class="type">ID_GENERATOR</span>.next,</span><br><span class="line">  <span class="keyword">new</span> <span class="type">BlockManagerStorageEndpoint</span>(rpcEnv, <span class="keyword">this</span>, mapOutputTracker))</span><br><span class="line"></span><br><span class="line"><span class="comment">// 向BlockManagerMasterEndpoint注册自己</span></span><br><span class="line"><span class="keyword">val</span> idFromMaster = master.registerBlockManager(</span><br><span class="line">  id,</span><br><span class="line">  diskBlockManager.localDirsString,</span><br><span class="line">  maxOnHeapMemory,</span><br><span class="line">  maxOffHeapMemory,</span><br><span class="line">  storageEndpoint)</span><br></pre></td></tr></table></figure>
<p>在向BlockManagerMasterEndpoint注册时就将BlockManagerStorageEndpoint一起已发送去了，随后又封装在blockManagerInfo对应的BlockManagerInfo中，这样BlockManagerMasterEndpoint就可以向任何一个BlockManager的BlockManagerStorageEndpoint发送消息了</p>
<h2 id="BlockManager"><a href="#BlockManager" class="headerlink" title="BlockManager"></a>BlockManager</h2><p>说了那么多终于到主角了，BlockManager运行在driver和executor上，它向用户提供了在磁盘或者内存中读取或者写入block数据的接口，在它之下仍然有更底层的实现（DiskStore、MemoryStore）</p>
<h3 id="BlockManager初始化"><a href="#BlockManager初始化" class="headerlink" title="BlockManager初始化"></a>BlockManager初始化</h3><p>创建BlockManager实例在SparkEnv中<code>val blockManager = new BlockManager(...</code>，创建实例的同时有许多组件也被实例化了，例如DiskBlockManager、MemoryStore、DiskStore、BlockManagerStorageEndpoint、BlockInfoManager等等。只有在调用它的initialize方法时该BlockManager才会真正被初始化</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">initialize</span></span>(appId: <span class="type">String</span>): <span class="type">Unit</span> = &#123;</span><br><span class="line">  blockTransferService.init(<span class="keyword">this</span>)</span><br><span class="line">  externalBlockStoreClient.foreach &#123; blockStoreClient =&gt;</span><br><span class="line">    blockStoreClient.init(appId)</span><br><span class="line">  &#125;</span><br><span class="line">  blockReplicationPolicy = &#123;</span><br><span class="line">    <span class="keyword">val</span> priorityClass = conf.get(config.<span class="type">STORAGE_REPLICATION_POLICY</span>)</span><br><span class="line">    <span class="keyword">val</span> clazz = <span class="type">Utils</span>.classForName(priorityClass)</span><br><span class="line">    <span class="keyword">val</span> ret = clazz.getConstructor().newInstance().asInstanceOf[<span class="type">BlockReplicationPolicy</span>]</span><br><span class="line">    logInfo(<span class="string">s&quot;Using <span class="subst">$priorityClass</span> for block replication policy&quot;</span>)</span><br><span class="line">    ret</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 初始化BlockManagerId</span></span><br><span class="line">  <span class="keyword">val</span> id = <span class="type">BlockManagerId</span>(executorId, blockTransferService.hostName, blockTransferService.port, <span class="type">None</span>)</span><br><span class="line">  <span class="comment">// 向BlockManagerMasterEndpoint注册自己</span></span><br><span class="line">  <span class="keyword">val</span> idFromMaster = master.registerBlockManager(</span><br><span class="line">    id,</span><br><span class="line">    diskBlockManager.localDirsString,</span><br><span class="line">    maxOnHeapMemory,</span><br><span class="line">    maxOffHeapMemory,</span><br><span class="line">    storageEndpoint)</span><br><span class="line"></span><br><span class="line">  blockManagerId = <span class="keyword">if</span> (idFromMaster != <span class="literal">null</span>) idFromMaster <span class="keyword">else</span> id</span><br><span class="line">  <span class="comment">// Shuffle的服务ID，一般也是当前BlockManagerId</span></span><br><span class="line">  shuffleServerId = <span class="keyword">if</span> (externalShuffleServiceEnabled) &#123;</span><br><span class="line">    logInfo(<span class="string">s&quot;external shuffle service port = <span class="subst">$externalShuffleServicePort</span>&quot;</span>)</span><br><span class="line">    <span class="type">BlockManagerId</span>(executorId, blockTransferService.hostName, externalShuffleServicePort)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    blockManagerId</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Register Executors&#x27; configuration with the local shuffle service, if one should exist.</span></span><br><span class="line">  <span class="keyword">if</span> (externalShuffleServiceEnabled &amp;&amp; !blockManagerId.isDriver) &#123;</span><br><span class="line">    registerWithExternalShuffleServer()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  hostLocalDirManager = &#123;</span><br><span class="line">    <span class="keyword">if</span> (conf.get(config.<span class="type">SHUFFLE_HOST_LOCAL_DISK_READING_ENABLED</span>) &amp;&amp;</span><br><span class="line">        !conf.get(config.<span class="type">SHUFFLE_USE_OLD_FETCH_PROTOCOL</span>)) &#123;</span><br><span class="line">      <span class="type">Some</span>(<span class="keyword">new</span> <span class="type">HostLocalDirManager</span>(</span><br><span class="line">        futureExecutionContext,</span><br><span class="line">        conf.get(config.<span class="type">STORAGE_LOCAL_DISK_BY_EXECUTORS_CACHE_SIZE</span>),</span><br><span class="line">        blockStoreClient))</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="type">None</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  logInfo(<span class="string">s&quot;Initialized BlockManager: <span class="subst">$blockManagerId</span>&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="write-block"><a href="#write-block" class="headerlink" title="write block"></a>write block</h3><p>write block最终都汇聚到两个方法，BlockStoreUpdater.save和BlockManager.doPutIterator，下面分别看一下这两个方法<br>BlockManager.doPutIterator写入iterator数据</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">def</span> <span class="title">doPutIterator</span></span>[<span class="type">T</span>](</span><br><span class="line">    blockId: <span class="type">BlockId</span>,</span><br><span class="line">    iterator: () =&gt; <span class="type">Iterator</span>[<span class="type">T</span>],</span><br><span class="line">    level: <span class="type">StorageLevel</span>,</span><br><span class="line">    classTag: <span class="type">ClassTag</span>[<span class="type">T</span>],</span><br><span class="line">    tellMaster: <span class="type">Boolean</span> = <span class="literal">true</span>,</span><br><span class="line">    keepReadLock: <span class="type">Boolean</span> = <span class="literal">false</span>): <span class="type">Option</span>[<span class="type">PartiallyUnrolledIterator</span>[<span class="type">T</span>]] = &#123;</span><br><span class="line">  doPut(blockId, level, classTag, tellMaster = tellMaster, keepReadLock = keepReadLock) &#123; info =&gt;</span><br><span class="line">    <span class="keyword">val</span> startTimeNs = <span class="type">System</span>.nanoTime()</span><br><span class="line">    <span class="keyword">var</span> iteratorFromFailedMemoryStorePut: <span class="type">Option</span>[<span class="type">PartiallyUnrolledIterator</span>[<span class="type">T</span>]] = <span class="type">None</span></span><br><span class="line">    <span class="comment">// Size of the block in bytes</span></span><br><span class="line">    <span class="keyword">var</span> size = <span class="number">0</span>L</span><br><span class="line">    <span class="keyword">if</span> (level.useMemory) &#123;</span><br><span class="line">      <span class="keyword">if</span> (level.deserialized) &#123;</span><br><span class="line">        <span class="comment">// 将给定的iterator放入对应的blockId中，最终调用MemoryStore.putIterator方法</span></span><br><span class="line">        memoryStore.putIteratorAsValues(blockId, iterator(), classTag) <span class="keyword">match</span> &#123;</span><br><span class="line">          <span class="keyword">case</span> <span class="type">Right</span>(s) =&gt;</span><br><span class="line">            size = s</span><br><span class="line">          <span class="comment">// 如果内存中没有足够空间放不下数据那么会尝试将数据放入磁盘中：StorageLevel.MEMORY_AND_DISK</span></span><br><span class="line">          <span class="keyword">case</span> <span class="type">Left</span>(iter) =&gt;</span><br><span class="line">            <span class="keyword">if</span> (level.useDisk) &#123;</span><br><span class="line">              logWarning(<span class="string">s&quot;Persisting block <span class="subst">$blockId</span> to disk instead.&quot;</span>)</span><br><span class="line">              diskStore.put(blockId) &#123; channel =&gt;</span><br><span class="line">                <span class="keyword">val</span> out = <span class="type">Channels</span>.newOutputStream(channel)</span><br><span class="line">                serializerManager.dataSerializeStream(blockId, out, iter)(classTag)</span><br><span class="line">              &#125;</span><br><span class="line">              size = diskStore.getSize(blockId)</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              iteratorFromFailedMemoryStorePut = <span class="type">Some</span>(iter)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123; <span class="comment">// !level.deserialized</span></span><br><span class="line">        memoryStore.putIteratorAsBytes(blockId, iterator(), classTag, level.memoryMode) <span class="keyword">match</span> &#123;</span><br><span class="line">          <span class="keyword">case</span> <span class="type">Right</span>(s) =&gt;</span><br><span class="line">            size = s</span><br><span class="line">          <span class="keyword">case</span> <span class="type">Left</span>(partiallySerializedValues) =&gt;</span><br><span class="line">            <span class="comment">// Not enough space to unroll this block; drop to disk if applicable</span></span><br><span class="line">            <span class="keyword">if</span> (level.useDisk) &#123;</span><br><span class="line">              logWarning(<span class="string">s&quot;Persisting block <span class="subst">$blockId</span> to disk instead.&quot;</span>)</span><br><span class="line">              diskStore.put(blockId) &#123; channel =&gt;</span><br><span class="line">                <span class="keyword">val</span> out = <span class="type">Channels</span>.newOutputStream(channel)</span><br><span class="line">                partiallySerializedValues.finishWritingToStream(out)</span><br><span class="line">              &#125;</span><br><span class="line">              size = diskStore.getSize(blockId)</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              iteratorFromFailedMemoryStorePut = <span class="type">Some</span>(partiallySerializedValues.valuesIterator)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    <span class="comment">// 如果没使用内存那么直接将数据放入磁盘中</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (level.useDisk) &#123;</span><br><span class="line">      diskStore.put(blockId) &#123; channel =&gt;</span><br><span class="line">        <span class="keyword">val</span> out = <span class="type">Channels</span>.newOutputStream(channel)</span><br><span class="line">        serializerManager.dataSerializeStream(blockId, out, iterator())(classTag)</span><br><span class="line">      &#125;</span><br><span class="line">      size = diskStore.getSize(blockId)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果写入成功这里会返回BlockStatus，包含写入级别、写入内存的数据大小和磁盘的数据大小（在MemoryStore和DiskStore中维护）</span></span><br><span class="line">    <span class="keyword">val</span> putBlockStatus = getCurrentBlockStatus(blockId, info)</span><br><span class="line">    <span class="keyword">val</span> blockWasSuccessfullyStored = putBlockStatus.storageLevel.isValid</span><br><span class="line">    <span class="keyword">if</span> (blockWasSuccessfullyStored) &#123;</span><br><span class="line">      info.size = size</span><br><span class="line">      <span class="comment">// 向BlockManagerMasterEndpoint发送更新Block状态的消息</span></span><br><span class="line">      <span class="keyword">if</span> (tellMaster &amp;&amp; info.tellMaster) &#123;</span><br><span class="line">        reportBlockStatus(blockId, putBlockStatus)</span><br><span class="line">      &#125;</span><br><span class="line">      addUpdatedBlockStatusToTaskMetrics(blockId, putBlockStatus)</span><br><span class="line">      logDebug(<span class="string">s&quot;Put block <span class="subst">$blockId</span> locally took <span class="subst">$&#123;Utils.getUsedTimeNs(startTimeNs)&#125;</span>&quot;</span>)</span><br><span class="line">      <span class="keyword">if</span> (level.replication &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">val</span> remoteStartTimeNs = <span class="type">System</span>.nanoTime()</span><br><span class="line">        <span class="keyword">val</span> bytesToReplicate = doGetLocalBytes(blockId, info)</span><br><span class="line">        <span class="keyword">val</span> remoteClassTag = <span class="keyword">if</span> (!serializerManager.canUseKryo(classTag)) &#123;</span><br><span class="line">          scala.reflect.classTag[<span class="type">Any</span>]</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          classTag</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          replicate(blockId, bytesToReplicate, level, remoteClassTag)</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">          bytesToReplicate.dispose()</span><br><span class="line">        &#125;</span><br><span class="line">        logDebug(<span class="string">s&quot;Put block <span class="subst">$blockId</span> remotely took <span class="subst">$&#123;Utils.getUsedTimeNs(remoteStartTimeNs)&#125;</span>&quot;</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    assert(blockWasSuccessfullyStored == iteratorFromFailedMemoryStorePut.isEmpty)</span><br><span class="line">    iteratorFromFailedMemoryStorePut</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>BlockStoreUpdater.save写入bytes数据</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">save</span></span>(): <span class="type">Boolean</span> = &#123;</span><br><span class="line">  doPut(blockId, level, classTag, tellMaster, keepReadLock) &#123; info =&gt;</span><br><span class="line">    <span class="keyword">val</span> startTimeNs = <span class="type">System</span>.nanoTime()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> replicationFuture = <span class="keyword">if</span> (level.replication &gt; <span class="number">1</span>) &#123;</span><br><span class="line">      <span class="type">Future</span> &#123;</span><br><span class="line">        <span class="comment">// 将block复制到另一个节点</span></span><br><span class="line">        replicate(blockId, blockData(), level, classTag)</span><br><span class="line">      &#125;(futureExecutionContext)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (level.useMemory) &#123;</span><br><span class="line">      <span class="comment">// 将block写入内存中</span></span><br><span class="line">      <span class="keyword">val</span> putSucceeded = <span class="keyword">if</span> (level.deserialized) &#123;</span><br><span class="line">        <span class="comment">// 如果是未经序列化的数据那么将它封装为BlockData并获取输入流最终调用MemoryStore.putIterator方法</span></span><br><span class="line">        saveDeserializedValuesToMemoryStore(blockData().toInputStream())</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 如果是序列化的bytes调用MemoryStore.putBytes方法</span></span><br><span class="line">        saveSerializedValuesToMemoryStore(readToByteBuffer())</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 如果内存写入失败那么写入到磁盘</span></span><br><span class="line">      <span class="keyword">if</span> (!putSucceeded &amp;&amp; level.useDisk) &#123;</span><br><span class="line">        logWarning(<span class="string">s&quot;Persisting block <span class="subst">$blockId</span> to disk instead.&quot;</span>)</span><br><span class="line">        saveToDiskStore()</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (level.useDisk) &#123;</span><br><span class="line">      <span class="comment">// 写入到磁盘，最终调用DiskStore.putBytes方法</span></span><br><span class="line">      saveToDiskStore()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 下面的流程就和BlockManager.doPutIterator方法一样了</span></span><br><span class="line">    <span class="keyword">val</span> putBlockStatus = getCurrentBlockStatus(blockId, info)</span><br><span class="line">    <span class="keyword">val</span> blockWasSuccessfullyStored = putBlockStatus.storageLevel.isValid</span><br><span class="line">    <span class="keyword">if</span> (blockWasSuccessfullyStored) &#123;</span><br><span class="line">      info.size = blockSize</span><br><span class="line">      <span class="keyword">if</span> (tellMaster &amp;&amp; info.tellMaster) &#123;</span><br><span class="line">        reportBlockStatus(blockId, putBlockStatus)</span><br><span class="line">      &#125;</span><br><span class="line">      addUpdatedBlockStatusToTaskMetrics(blockId, putBlockStatus)</span><br><span class="line">    &#125;</span><br><span class="line">    logDebug(<span class="string">s&quot;Put block <span class="subst">$&#123;blockId&#125;</span> locally took <span class="subst">$&#123;Utils.getUsedTimeNs(startTimeNs)&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> (level.replication &gt; <span class="number">1</span>) &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">ThreadUtils</span>.awaitReady(replicationFuture, <span class="type">Duration</span>.<span class="type">Inf</span>)</span><br><span class="line">      &#125; <span class="keyword">catch</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="type">NonFatal</span>(t) =&gt;</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">SparkException</span>(<span class="string">&quot;Error occurred while waiting for replication to finish&quot;</span>, t)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (blockWasSuccessfullyStored) &#123;</span><br><span class="line">      <span class="type">None</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="type">Some</span>(blockSize)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;.isEmpty</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="read-block"><a href="#read-block" class="headerlink" title="read block"></a>read block</h3><p>read block同样分为两个方法，BlockManager.getLocalValues和BlockManager.getRemoteBlock，分别是从本地获取block和从远程获取block，当然内部也同样分为直接读取values和读取bytes两种方式</p>
<p>BlockManager.getLocalValues从本地获取block</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getLocalValues</span></span>(blockId: <span class="type">BlockId</span>): <span class="type">Option</span>[<span class="type">BlockResult</span>] = &#123;</span><br><span class="line">  logDebug(<span class="string">s&quot;Getting local block <span class="subst">$blockId</span>&quot;</span>)</span><br><span class="line">  blockInfoManager.lockForReading(blockId) <span class="keyword">match</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="type">None</span> =&gt;</span><br><span class="line">      logDebug(<span class="string">s&quot;Block <span class="subst">$blockId</span> was not found&quot;</span>)</span><br><span class="line">      <span class="type">None</span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">Some</span>(info) =&gt;</span><br><span class="line">      <span class="keyword">val</span> level = info.level</span><br><span class="line">      logDebug(<span class="string">s&quot;Level for block <span class="subst">$blockId</span> is <span class="subst">$level</span>&quot;</span>)</span><br><span class="line">      <span class="keyword">val</span> taskContext = <span class="type">Option</span>(<span class="type">TaskContext</span>.get())</span><br><span class="line">      <span class="keyword">if</span> (level.useMemory &amp;&amp; memoryStore.contains(blockId)) &#123;</span><br><span class="line">        <span class="comment">// 从内存中获取block，如果未经序列化那么直接读取并返回，如果序列化了那么需要调用SerializerManager.dataDeserializeStream进行反序列化</span></span><br><span class="line">        <span class="keyword">val</span> iter: <span class="type">Iterator</span>[<span class="type">Any</span>] = <span class="keyword">if</span> (level.deserialized) &#123;</span><br><span class="line">          memoryStore.getValues(blockId).get</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          serializerManager.dataDeserializeStream(</span><br><span class="line">            blockId, memoryStore.getBytes(blockId).get.toInputStream())(info.classTag)</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 包装iterator并释放读锁，返回BlockResult</span></span><br><span class="line">        <span class="keyword">val</span> ci = <span class="type">CompletionIterator</span>[<span class="type">Any</span>, <span class="type">Iterator</span>[<span class="type">Any</span>]](iter, &#123;</span><br><span class="line">          releaseLock(blockId, taskContext)</span><br><span class="line">        &#125;)</span><br><span class="line">        <span class="type">Some</span>(<span class="keyword">new</span> <span class="type">BlockResult</span>(ci, <span class="type">DataReadMethod</span>.<span class="type">Memory</span>, info.size))</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (level.useDisk &amp;&amp; diskStore.contains(blockId)) &#123;</span><br><span class="line">        <span class="comment">// 从磁盘读取block数据</span></span><br><span class="line">        <span class="keyword">val</span> diskData = diskStore.getBytes(blockId)</span><br><span class="line">        <span class="keyword">val</span> iterToReturn: <span class="type">Iterator</span>[<span class="type">Any</span>] = &#123;</span><br><span class="line">          <span class="keyword">if</span> (level.deserialized) &#123;</span><br><span class="line">            <span class="keyword">val</span> diskValues = serializerManager.dataDeserializeStream(</span><br><span class="line">              blockId,</span><br><span class="line">              diskData.toInputStream())(info.classTag)</span><br><span class="line">            <span class="comment">// 尝试将数据缓存到内存以加快后续读取速度</span></span><br><span class="line">            maybeCacheDiskValuesInMemory(info, blockId, level, diskValues)</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">val</span> stream = maybeCacheDiskBytesInMemory(info, blockId, level, diskData)</span><br><span class="line">              .map &#123; _.toInputStream(dispose = <span class="literal">false</span>) &#125;</span><br><span class="line">              .getOrElse &#123; diskData.toInputStream() &#125;</span><br><span class="line">            serializerManager.dataDeserializeStream(blockId, stream)(info.classTag)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 包装iterator并释放读锁，返回BlockResult</span></span><br><span class="line">        <span class="keyword">val</span> ci = <span class="type">CompletionIterator</span>[<span class="type">Any</span>, <span class="type">Iterator</span>[<span class="type">Any</span>]](iterToReturn, &#123;</span><br><span class="line">          releaseLockAndDispose(blockId, diskData, taskContext)</span><br><span class="line">        &#125;)</span><br><span class="line">        <span class="type">Some</span>(<span class="keyword">new</span> <span class="type">BlockResult</span>(ci, <span class="type">DataReadMethod</span>.<span class="type">Disk</span>, info.size))</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        handleLocalReadFailure(blockId)</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>BlockManager.getRemoteBlock远程获取block</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span>[spark] <span class="function"><span class="keyword">def</span> <span class="title">getRemoteBlock</span></span>[<span class="type">T</span>](</span><br><span class="line">    blockId: <span class="type">BlockId</span>,</span><br><span class="line">    bufferTransformer: <span class="type">ManagedBuffer</span> =&gt; <span class="type">T</span>): <span class="type">Option</span>[<span class="type">T</span>] = &#123;</span><br><span class="line">  logDebug(<span class="string">s&quot;Getting remote block <span class="subst">$blockId</span>&quot;</span>)</span><br><span class="line">  require(blockId != <span class="literal">null</span>, <span class="string">&quot;BlockId is null&quot;</span>)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 因为所有的block都在driver注册，所以直接去driver查找block在本地运行的其他作业的location和status</span></span><br><span class="line">  <span class="keyword">val</span> locationsAndStatusOption = master.getLocationsAndStatus(blockId, blockManagerId.host)</span><br><span class="line">  <span class="keyword">if</span> (locationsAndStatusOption.isEmpty) &#123;</span><br><span class="line">    logDebug(<span class="string">s&quot;Block <span class="subst">$blockId</span> is unknown by block manager master&quot;</span>)</span><br><span class="line">    <span class="type">None</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">val</span> locationsAndStatus = locationsAndStatusOption.get</span><br><span class="line">    <span class="keyword">val</span> blockSize = locationsAndStatus.status.diskSize.max(locationsAndStatus.status.memSize)</span><br><span class="line"></span><br><span class="line">    locationsAndStatus.localDirs.flatMap &#123; localDirs =&gt;</span><br><span class="line">      <span class="comment">// 从在同一主机上运行的其他作业的本地目录中读取block数据，随后转换为ManagedBuffer</span></span><br><span class="line">      <span class="keyword">val</span> blockDataOption =</span><br><span class="line">        readDiskBlockFromSameHostExecutor(blockId, localDirs, locationsAndStatus.status.diskSize)</span><br><span class="line">      <span class="keyword">val</span> res = blockDataOption.flatMap &#123; blockData =&gt;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="type">Some</span>(bufferTransformer(blockData))</span><br><span class="line">        &#125; <span class="keyword">catch</span> &#123;</span><br><span class="line">          <span class="keyword">case</span> <span class="type">NonFatal</span>(e) =&gt;</span><br><span class="line">            logDebug(<span class="string">&quot;Block from the same host executor cannot be opened: &quot;</span>, e)</span><br><span class="line">            <span class="type">None</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      logInfo(<span class="string">s&quot;Read <span class="subst">$blockId</span> from the disk of a same host executor is &quot;</span> +</span><br><span class="line">        (<span class="keyword">if</span> (res.isDefined) <span class="string">&quot;successful.&quot;</span> <span class="keyword">else</span> <span class="string">&quot;failed.&quot;</span>))</span><br><span class="line">      res</span><br><span class="line">    &#125;.orElse &#123;</span><br><span class="line">      <span class="comment">// 如果为空就去driver或者其他executor查找，它从locationsAndStatus拿到block所在的host、port以及executorId获取对应的blockId数据</span></span><br><span class="line">      fetchRemoteManagedBuffer(blockId, blockSize, locationsAndStatus).map(bufferTransformer)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="remove-block"><a href="#remove-block" class="headerlink" title="remove block"></a>remove block</h3><p>remove block没什么好说的，分别从MemoryStore和DiskStore移除对应blockId的block数据</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">def</span> <span class="title">removeBlockInternal</span></span>(blockId: <span class="type">BlockId</span>, tellMaster: <span class="type">Boolean</span>): <span class="type">Unit</span> = &#123;</span><br><span class="line">  <span class="keyword">val</span> blockStatus = <span class="keyword">if</span> (tellMaster) &#123;</span><br><span class="line">    <span class="keyword">val</span> blockInfo = blockInfoManager.assertBlockIsLockedForWriting(blockId)</span><br><span class="line">    <span class="type">Some</span>(getCurrentBlockStatus(blockId, blockInfo))</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="type">None</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 分别从memory和disk移除block</span></span><br><span class="line">  <span class="keyword">val</span> removedFromMemory = memoryStore.remove(blockId)</span><br><span class="line">  <span class="keyword">val</span> removedFromDisk = diskStore.remove(blockId)</span><br><span class="line">  <span class="keyword">if</span> (!removedFromMemory &amp;&amp; !removedFromDisk) &#123;</span><br><span class="line">    logWarning(<span class="string">s&quot;Block <span class="subst">$blockId</span> could not be removed as it was not found on disk or in memory&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// blockInfoManager移除掉blockId和BlockInfo的映射关系</span></span><br><span class="line">  blockInfoManager.removeBlock(blockId)</span><br><span class="line">  <span class="keyword">if</span> (tellMaster) &#123;</span><br><span class="line">    reportBlockStatus(blockId, blockStatus.get.copy(storageLevel = <span class="type">StorageLevel</span>.<span class="type">NONE</span>))</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="其他组件"><a href="#其他组件" class="headerlink" title="其他组件"></a>其他组件</h3><ul>
<li>BlockInfoManager：管理当前BlockManager上面所有的BlockInfo，它维护了一个<code>infos: mutable.HashMap[BlockId, BlockInfo]</code>存储现有的block映射，<code>writeLocksByTask: mutable.HashMap[TaskAttemptId, mutable.Set[BlockId]]</code>用来维护每个task对block加的写锁，<code>readLocksByTask: mutable.HashMap[TaskAttemptId, ConcurrentHashMultiset[BlockId]]</code>维护每个task对block加的读锁，每个block可以有多个读锁。同时也提供这些block的读写锁的释放</li>
<li>BlockInfo：跟踪保存每个Block的元数据</li>
<li>BlockId：标识不同block的接口，它的实现有RDDBlockId、ShuffleBlockId、ShuffleDataBlockId等等</li>
<li>BlockData：抽象出block的读取方式，并提供读取底层数据的不同方法</li>
<li>DiskBlockManager：创建并维护每个block到文件地址的映射，一个block映射一个文件。主要的方法就是getFile，根据filename确定文件的路径并返回，还有创建SPARK_LOCAL_DIRS文件夹清理文件夹的功能</li>
<li>DiskStore：结合DiskBlockManager提供外部读取和写入block的接口，具体方式就是DiskBlockManager通过blockId计算其hash值的方式确定每个block存储的file</li>
<li>MemoryManager：管理计算的内存和存储的内存，唯一的实现类是UnifiedMemoryManager，它要解决的问题是需要提供多大的内存用于Store存储</li>
<li>MemoryStore：数据以MemoryEntry的方形式存在<code>private val entries = new LinkedHashMap[BlockId, MemoryEntry[_]]</code>中，MemoryStore要做的就是对外提供接口对entries进行管理。有关Spark内存的管理查看<a href="">Spark-Memory</a></li>
</ul>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="mailto:undefined">WangXun</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="https://wangxukun.top/2022/11/02/Software/Spark进阶-BlockManager/">https://wangxukun.top/2022/11/02/Software/Spark进阶-BlockManager/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Spark/">Spark</a></div><nav id="pagination"><div class="prev-post pull-left"><a href="/2022/11/12/Software/Spark%E8%BF%9B%E9%98%B6-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"><i class="fa fa-chevron-left">  </i><span>Spark进阶-内存管理</span></a></div><div class="next-post pull-right"><a href="/2022/10/23/Software/Spark%E6%BA%90%E7%A0%81-broadcast%E6%B5%81%E7%A8%8B%E5%8E%9F%E7%90%86/"><span>Spark源码-broadcast流程原理</span><i class="fa fa-chevron-right"></i></a></div></nav><div id="gitalk-container"></div><script>var gitalk = new Gitalk({
  clientID: 'aaf2844e0aeef4917c17',
  clientSecret: '10b96d24dffda7d3b4544778cf620f81990b676d',
  repo: 'blog-issue',
  owner: 'w749',
  admin: 'w749',
  id: md5(decodeURI(location.pathname)),
  language: 'en'
})
gitalk.render('gitalk-container')</script></div></div><footer class="footer-bg" style="background-image: url(/img/top-img.jpg)"><div class="layout" id="footer"><div class="copyright">&copy;2019 - 2022 By WangXun</div><div class="framework-info"><span>Driven - </span><a target="_blank" rel="noopener" href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme - </span><a target="_blank" rel="noopener" href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="footer_custom_text">hitokoto</div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-eye"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/lib/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.9.1"></script><script src="/js/fancybox.js?version=1.9.1"></script><script src="/js/sidebar.js?version=1.9.1"></script><script src="/js/copy.js?version=1.9.1"></script><script src="/js/fireworks.js?version=1.9.1"></script><script src="/js/transition.js?version=1.9.1"></script><script src="/js/scroll.js?version=1.9.1"></script><script src="/js/head.js?version=1.9.1"></script><script src="/js/search/algolia.js"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script><div class="search-dialog" id="algolia-search"><div class="search-dialog__title" id="algolia-search-title">Algolia</div><div id="algolia-input-panel"><div id="algolia-search-input"></div></div><hr><div id="algolia-search-results"><div id="algolia-hits"></div><div id="algolia-pagination"></div><div id="algolia-stats"></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div></body></html>